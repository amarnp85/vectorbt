---
description: Guide for using Task Master to manage task-driven development workflows
globs: **/*
alwaysApply: true
---
# Development Workflow

## Core Development Principles

- **Clean Code Philosophy**: Write less code that does more by leveraging VectorBT Pro's capabilities
- **Test-Driven Development**: Create test files to verify functionality, then delete them
- **Documentation-First**: Always check `vectorbtpro_docs/` before implementing features
- **Modular Architecture**: Keep components independent and reusable

## Standard Development Process

### 1. Feature Planning
- Check if VectorBT Pro already provides the functionality
- Review existing modules to avoid duplication
- Plan integration with existing architecture

### 2. Implementation Workflow
```python
# Step 1: Create a test file (e.g., test_feature.py)
import vectorbtpro as vbt
from backtester.data import fetch_data

# Step 2: Test your implementation
data = fetch_data(['BTC/USDT'], '1h', limit=1000)
# ... test code ...

# Step 3: Verify results
print(results)

# Step 4: Integrate into appropriate module
# Step 5: Delete test file
```

### 3. Code Integration
- Add new functionality to existing modules when possible
- Create new files only when necessary for modularity
- Update examples in `examples/` directory
- Avoid creating documentation files

## Strategy Development Workflow

### 1. Create Strategy Class
```python
# backtester/strategies/my_strategy.py
from backtester.strategies.base import BaseStrategy

class MyStrategy(BaseStrategy):
    def __init__(self, **params):
        super().__init__(**params)
        # Validate parameters
    
    def calculate_indicators(self, data):
        # Use VBT indicators
        pass
    
    def generate_signals(self, data, indicators):
        # Generate entry/exit signals
        pass
```

### 2. Test Strategy
```python
# Use examples/strategy_tester.py
from backtester.strategies.my_strategy import MyStrategy

# Test with fixed date range for consistency
strategy = MyStrategy(param1=value1, param2=value2)
results = test_strategy(strategy, symbols=['BTC/USDT'], timeframe='1h')
```

### 3. Optimize Parameters
- Use existing optimization framework
- Store optimal parameters in database
- Add to `config/strategy_params/`

## Data Management Workflow

### 1. Data Fetching
```python
# Always use the standard interface
from backtester.data import fetch_data

data = fetch_data(
    symbols=['BTC/USDT', 'ETH/USDT'],
    timeframe='1h',
    start='2023-01-01',
    end='2023-12-31'
)
```

### 2. Data Caching
- Automatic caching is handled by the framework
- Check cache before fetching
- Use appropriate cache keys

## Testing Best Practices

### 1. Unit Testing
- Test individual components in isolation
- Use VBT's testing utilities
- Focus on edge cases

### 2. Integration Testing
- Test complete strategies
- Verify portfolio calculations
- Check performance metrics

### 3. Performance Testing
- Use consistent date ranges
- Compare against benchmarks
- Monitor execution time

## Configuration Management

### 1. Strategy Parameters
```yaml
# config/strategy_params/production/strategy_name.yaml
BTC/USDT:
  param1: value1
  param2: value2
ETH/USDT:
  param1: value3
  param2: value4
```

### 2. Environment Configuration
- Use `.env` for sensitive data
- Keep exchange configs centralized
- Version control non-sensitive configs

## Performance Optimization

### 1. Use VBT's Optimization Features
- Leverage vectorized operations
- Enable parallel processing
- Use caching decorators

### 2. Memory Management
- Process data in chunks for large datasets
- Clear unnecessary variables
- Use VBT's memory-efficient methods

## Common Development Patterns

### 1. Adding New Indicators
```python
# Check if VBT has it first
indicator = vbt.IndicatorName.run(data.close, **params)

# If custom needed, extend VBT
class CustomIndicator(vbt.indicators.factory.IndicatorFactory):
    # Implementation
```

### 2. Extending Functionality
- Build on top of VBT classes
- Use composition over inheritance
- Keep extensions minimal

### 3. Error Handling
```python
from backtester.utilities.logging import get_logger

logger = get_logger(__name__)

try:
    # Operation
except vbt.portfolio.errors.CashError:
    logger.error("Insufficient cash")
    # Handle appropriately
```

## Code Review Checklist

- [ ] Uses VBT methods where available
- [ ] No duplicate functionality
- [ ] Proper error handling
- [ ] Appropriate logging
- [ ] Test files deleted
- [ ] Configuration externalized
- [ ] Examples updated if needed
- [ ] No unnecessary files created

Remember: **The best code is the code you don't have to write - use VectorBT Pro's features!**